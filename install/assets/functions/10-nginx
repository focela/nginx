#!/command/with-contenv bash

# Check for legacy Nginx configurations and migrate them to the new structure.
# This function identifies the deprecated `/etc/nginx/conf.d/` directory and moves its content
# to `/etc/nginx/sites.available` to align with modern configuration practices.
nginx_check_legacy_configuration() {
    if [ -d "/etc/nginx/conf.d/" ]; then
        # Copy existing files from legacy directory to the new configuration path
        silent cp -R /etc/nginx/conf.d/* /etc/nginx/sites.available

        # Notify the user about the legacy configuration and migration
        print_warn "Found old legacy /etc/nginx/conf.d folder - Please switch to the new method of Nginx configuration using /etc/nginx/sites.available - Moving all files to /etc/nginx/sites.available"

        # Rename the legacy directory for backup purposes
        silent mv /etc/nginx/conf.d /etc/nginx/conf.d.legacy
    fi
}

# Group for general Nginx configuration.
# This section includes functions to configure global Nginx settings such as authentication, logging, maintenance mode, and more.
# The authentication configuration function supports multiple methods, including Basic, LDAP, and LLNG.
nginx_configure_authentication() {
    ### Map Authentication
    case "${NGINX_AUTHENTICATION_TYPE,,}" in
        # Basic authentication configuration
        "basic")
            print_notice "Setting Basic Authentication"

            # Count the number of users defined in environment variables
            user_num=$(printenv | sort | grep -c 'NGINX_AUTHENTICATION_BASIC_USER.*')

            # Loop through users and create the authentication file
            for ((i = 1; i <= user_num; i++)); do
                transform_file_var \
                    NGINX_AUTHENTICATION_BASIC_USER${i} \
                    NGINX_AUTHENTICATION_BASIC_PASS${i}

                basic_user=NGINX_AUTHENTICATION_BASIC_USER${i}
                basic_pass=NGINX_AUTHENTICATION_BASIC_PASS${i}

                print_warn "Creating User: ${!basic_user}"
                htpasswd -b -n "${!basic_user:-$NGINX_AUTHENTICATION_BASIC_USER}" "${!basic_pass:-$NGINX_AUTHENTICATION_BASIC_PASS}" >> /etc/nginx/snippets/authentication/basic_authorized_users
            done
        ;;

        # LDAP authentication configuration
        "ldap")
            transform_file_var \
                NGINX_AUTHENTICATION_LDAP_HOST \
                NGINX_AUTHENTICATION_LDAP_PORT \
                NGINX_AUTHENTICATION_LDAP_BASE_DN \
                NGINX_AUTHENTICATION_LDAP_BIND_DN \
                NGINX_AUTHENTICATION_LDAP_BIND_PW

            # Generate LDAP server configuration for Nginx
            cat <<EOF > /etc/nginx/snippets/authentication/ldap_configuration
        ldap_server ldapserver {
          url "${NGINX_AUTHENTICATION_LDAP_HOST}/${NGINX_AUTHENTICATION_LDAP_BASE_DN}?${NGINX_AUTHENTICATION_LDAP_ATTRIBUTE}?${NGINX_AUTHENTICATION_LDAP_SCOPE}?${NGINX_AUTHENTICATION_LDAP_FILTER}";
          binddn "${NGINX_AUTHENTICATION_LDAP_BIND_DN}";
          binddn_passwd ${NGINX_AUTHENTICATION_LDAP_BIND_PW};
          group_attribute ${NGINX_AUTHENTICATION_LDAP_GROUP_ATTRIBUTE};
          group_attribute_is_dn on;
          require valid_user;
          satisfy all;
        }
EOF
            # Include the LDAP configuration snippet in Nginx's main configuration
            sed -i "\|include /etc/nginx/sites.enabled| i\ \ \ \ include /etc/nginx/snippets/authentication/ldap_configuration;" /etc/nginx/nginx.conf
        ;;

        # LLNG (LemonLDAP::NG) authentication configuration
        "llng")
            print_notice "Setting LLNG Authentication"

            # Handle upstream keepalive setting
            if var_true "${NGINX_ENABLE_UPSTREAM_KEEPALIVE}" ; then
                upstream_keepalive="keepalive ${NGINX_UPSTREAM_KEEPALIVE};"
            fi

            transform_file_var \
                NGINX_AUTHENTICATION_LLNG_HANDLER_HOST \
                NGINX_AUTHENTICATION_LLNG_HANDLER_PORT

            llng_upstream_hosts=$(echo "${NGINX_AUTHENTICATION_LLNG_HANDLER_HOST}" | tr "," "\n")

            # Generate upstream configuration
            echo "upstream llng-upstream-pool {" >> /etc/nginx/snippets/authentication/llng_upstream
            echo "     ${upstream_keepalive}" >> /etc/nginx/snippets/authentication/llng_upstream

            for host in $llng_upstream_hosts; do
                if [[ ${host} != *":"* ]];then
                    llng_handler_listen_port=":${NGINX_AUTHENTICATION_LLNG_HANDLER_PORT}"
                else
                    llng_handler_listen_port=""
                fi
                echo "    server $host${llng_handler_listen_port} ${NGINX_UPSTREAM_OPTIONS};" >> /etc/nginx/snippets/authentication/llng_upstream
            done
            echo "}" >> /etc/nginx/snippets/authentication/llng_upstream

            # Insert upstream configuration into Nginx
            sed -i -e "/# Do not delete - Upstream Configuration/a\ \ \ \ include \/etc\/nginx\/snippets\/authentication\/llng_upstream;" /etc/nginx/nginx.conf
            sed -i -e "/# Do not delete - Upstream Configuration/a\ \ \ \ ### LLNG Authentication Multiple Handlers configuration" /etc/nginx/nginx.conf

            update_template /etc/nginx/snippets/authentication/llng_location_block NGINX_AUTHENTICATION_LLNG_HANDLER_PORT

            # Configure additional LLNG attributes if PHP-FPM is not managing them
            if [ ! -f "/etc/cont-init.d/20-php-fpm" ]; then
                header_num=$(printenv | sort | grep -c '^NGINX_AUTHENTICATION_LLNG_ATTRIBUTE.*')
                for ((i = 1; i <= header_num; i++)); do
                    headers=NGINX_AUTHENTICATION_LLNG_ATTRIBUTE${i}
                    IFS=',' read -r -a array <<<"${!headers}"
                    print_notice "Updating Nginx to support receiving attribute from LLNG: '${array[0]}'"
                    echo "fastcgi_param ${array[0]} \$${array[1]};" >> /etc/nginx/snippets/authentication/llng_params
                    echo "auth_request_set \$${array[1]} \$${array[2]};" >> /etc/nginx/snippets/authentication/llng_auth_request
                done
            else
                print_debug "Skipping LLNG Authentication configuration until configured by PHP-FPM"
            fi
        ;;

        # No authentication
        "none")
            :
        ;;

        # Unknown authentication type fallback
        *)
            print_warn "Unknown NGINX_AUTHENTICATION_TYPE '${NGINX_AUTHENTICATION_TYPE}. Reverting to no/application authentication"
        ;;
    esac
}

# Configure bot blocking for Nginx.
# This function sets up rules to block unwanted bots by managing blacklist and whitelist configurations
# for user agents, IP addresses, and referrer domains. It also supports adding custom bot-blocking rules.
nginx_configure_blockbots() {
    ### Include blockbots configuration into site configurations
    sed -i "\|### Don't edit past here|a\ \ \ \ \  include /etc/nginx/snippets/blockbots/ddos.conf;" /etc/nginx/sites.available/*.conf

    ### Ensure required custom configuration files exist
    for config in bad-referrer-words.conf blacklist-ips.conf blacklist-user-agents.conf \
                  custom-bad-referrers.conf whitelist-ips.conf whitelist-domains.conf; do
        if [ ! -f "/etc/nginx/snippets/blockbots-custom/${config}" ]; then
            cp -R "/etc/nginx/snippets/blockbots/${config}" "/etc/nginx/snippets/blockbots-custom/"
        fi
    done

    ### Handle custom bot-blocking configurations from assets
    if [ -d "/assets/nginx/blockbots-custom" ] ; then
        print_notice "Detected Custom Bot Blocking configuration"
        cp -R /assets/nginx/blockbots-custom/* /etc/nginx/snippets/blockbots-custom/
    fi

    ### Manage whitelist domains
    if [ -n "${NGINX_BLOCK_BOTS_WHITELIST_DOMAIN}" ]; then
        whitelist_domains=$(echo "${NGINX_BLOCK_BOTS_WHITELIST_DOMAIN,,}" | tr "," "\n")
        for wl_domain in $whitelist_domains; do
            wl_domain_orig=${wl_domain}
            wl_domain="$(echo "$wl_domain" | sed "s|\\.|\\\.|g" | sed "s|-|\\\-|g")"
            if ! grep -q "${wl_domain_orig}" /etc/nginx/snippets/blockbots-custom/whitelist-domains.conf ; then
                print_debug  "Adding '${wl_domain_orig}' domain to bot blocker whitelist"
                echo '"~*(?:\b)'$(echo "$wl_domain")'(?:\b)" 0;' $(echo " # ${wl_domain_orig} automatically added on") $(date +"%Y-%m-%d-%H:%M:%S") >> /etc/nginx/snippets/blockbots-custom/whitelist-domains.conf
            elsebolster-zipping-tartly-swimsuit
                print_debug "Skipping '${wl_domain_orig}' to be added to bot blocker domain whitelist"
            fi
        done
    fi

    ### Manage whitelist IPs
    if [ -n "${NGINX_BLOCK_BOTS_WHITELIST_IP}" ]; then
        whitelist_ips=$(echo "${NGINX_BLOCK_BOTS_WHITELIST_IP}" | tr "," "\n")
        for wl_ip in $whitelist_ips; do
            if ! grep -q "${wl_ip}" /etc/nginx/snippets/blockbots-custom/whitelist-ips.conf ; then
                print_debug  "Adding IP: '${wl_ip}' to bot blocker whitelist"
                echo "${wl_ip} 0; # Automatically added on $(date +"%Y-%m-%d-%H:%M:%S")" >> /etc/nginx/snippets/blockbots-custom/whitelist-ips.conf
            else
                print_debug "Skipping IP: '${wl_ip}' from being added to bot blocker IP whitelist"
            fi
        done
    fi

    ### Manage bot blacklists
    if [ -n "${NGINX_BLOCK_BOTS}" ] ; then
        if [[ "${NGINX_BLOCK_BOTS,,}" == *"all" ]] ; then
            NGINX_BLOCK_BOTS=ALL
        fi

        IFS=","
        for bot in $NGINX_BLOCK_BOTS ; do
            case "${bot,,}" in
                "all" )
                    nginx_block_bots="adidxbot,aolbuild,bingbot,bingpreview,DoCoMo,duckduckgo,facebookexternalhit,facebookplatform,AdsBot-Google,Googlebot,Googlebot-Image,Googlebot-Mobile,Googlebot-News,Googlebot/Test,Googlebot-Video,Google-HTTP-Java-Client,LinkedInBot,Gravityscan,Jakarta\\ Commons,Kraken/0.1,teoma,msnbot,msnbot-media,SAMSUNG,Slackbot,Slackbot-LinkExpanding,slurp,TwitterBot,Wordpress,yahoo"
                ;;
                "aol" )
                    nginx_block_bots="aolbuild,${nginx_block_bots}"
                ;;
                "bing" )
                    nginx_block_bots="bingbot,bingpreview,${nginx_block_bots}"
                ;;
                "docomo" )
                    nginx_block_bots="DoCoMo,${nginx_block_bots}"
                ;;
                "duckduckgo" )
                    nginx_block_bots="duckduckgo,${nginx_block_bots}"
                ;;
                "facebook" )
                    nginx_block_bots="developers.facebook.com,facebookexternalhit,facebookplatform,${nginx_block_bots}"
                ;;
                "google" )
                    nginx_block_bots="AdsBot-Google,Googlebot,Googlebot-Image,Googlebot-Mobile,Googlebot-News,Googlebot/Test,Googlebot-Video,Google-HTTP-Java-Client,${nginx_block_bots}"
                ;;
                "linkedin" )
                    nginx_block_bots="LinkedInBot,${nginx_block_bots}"
                ;;
                "misc" )
                    nginx_block_bots="adidxbot,Gravityscan,'Jakarta\ Commons',Kraken/0.1,teoma,${nginx_block_bots}"
                ;;
                "msn" )
                    nginx_block_bots="msnbot,msnbot-media,${nginx_block_bots}"
                ;;
                "samsung" )
                    nginx_block_bots="SAMSUNG,${nginx_block_bots}"
                ;;
                "slack" )
                    nginx_block_bots="Slackbot,Slackbot-LinkExpanding,${nginx_block_bots}"
                ;;
                "slurp" )
                    nginx_block_bots="slurp,${nginx_block_bots}"
                ;;
                "twitter" )
                    nginx_block_bots="TwitterBot,${nginx_block_bots}"
                ;;
                "wordpress" )
                    nginx_block_bots="Wordpress,${nginx_block_bots}"
                ;;
                "yahoo" )
                    nginx_block_bots="yahoo,${nginx_block_bots}"
                ;;
                * )
                    nginx_block_bots="${bot},${nginx_block_bots}"
                ;;
            esac
        done
        NGINX_BLOCK_BOTS_BLACKLIST_USER_AGENTS="${nginx_block_bots}"
    fi

    ### Update blacklist user agents
    if [ -n "${NGINX_BLOCK_BOTS_BLACKLIST_USER_AGENTS}" ]; then
        IFS=","
        for blacklist_ua in $NGINX_BLOCK_BOTS_BLACKLIST_USER_AGENTS; do
            blacklist_ua_orig="$(echo "$blacklist_ua" | sed "s|\\\||g")"
            if ! grep -q "${blacklist_ua_orig}" /etc/nginx/snippets/blockbots-custom/blacklist-user-agents.conf ; then
                print_debug  "[botblock] Adding UA: '${blacklist_ua_orig}' to bot blocker blacklist"
                echo '"~*(?:\b)'$(echo "$blacklist_ua")'(?:\b)" 3; # '${blacklist_ua_orig}' Automatically added on '$(date +"%Y-%m-%d-%H:%M:%S") >> /etc/nginx/snippets/blockbots-custom/blacklist-user-agents.conf
            else
                print_debug "Skipping UA: '${blacklist_ua_orig}' from being added to bot blocker blacklist"
            fi
        done
    fi
}

# Configure logging for Nginx.
# This function sets up access, error, and blocked request logs for Nginx.
# It ensures log directories are created, log files are initialized, and log rotation is configured.
nginx_configure_logging() {
    ### Update logging configuration
    # Replace placeholders in the logging template with actual values from environment variables
    update_template /etc/nginx/snippets/logging.conf \
        NGINX_LOG_ACCESS_FILE \
        NGINX_LOG_ACCESS_LOCATION \
        NGINX_LOG_ACCESS_FORMAT \
        NGINX_LOG_ERROR_FILE \
        NGINX_LOG_LEVEL_ERROR \
        NGINX_LOG_ERROR_LOCATION

    ### Create log directories and files
    # Ensure the required directories exist
    mkdir -p "${NGINX_LOG_ERROR_LOCATION}" "${NGINX_LOG_ACCESS_LOCATION}"
    # Create or update access and error log files
    touch "${NGINX_LOG_ERROR_LOCATION}/${NGINX_LOG_ERROR_FILE}"
    touch "${NGINX_LOG_ACCESS_LOCATION}/${NGINX_LOG_ACCESS_FILE}"
    # Set ownership for log directories and files
    chown -R "${NGINX_USER}" "${NGINX_LOG_ERROR_LOCATION}" "${NGINX_LOG_ACCESS_LOCATION}"

    ### Configure log rotation for standard logs
    # Access logs
    create_logrotate nginx-access \
        "${NGINX_LOG_ACCESS_LOCATION}/${NGINX_LOG_ACCESS_FILE}" \
        nginx-"${NGINX_LOG_ACCESS_FORMAT}" \
        "${NGINX_USER}" "${NGINX_GROUP}"
    # Error logs
    create_logrotate nginx-error \
        "${NGINX_LOG_ACCESS_LOCATION}/${NGINX_LOG_ERROR_FILE}" \
        nginx-error-standard,nginx-error-alt-standard \
        "${NGINX_USER}" "${NGINX_GROUP}"

    ### Configure exploit protection logs (if enabled)
    if var_true "${NGINX_ENABLE_EXPLOIT_PROTECTION}" ; then
        # Create exploit protection log directory and file
        mkdir -p "${NGINX_LOG_BLOCKED_LOCATION}"
        touch "${NGINX_LOG_BLOCKED_LOCATION}/${NGINX_LOG_BLOCKED_FILE}"

        # Update logging configuration for blocked requests
        update_template /etc/nginx/snippets/exploit_protection.conf \
            NGINX_LOG_BLOCKED_LOCATION \
            NGINX_LOG_BLOCKED_FILE \
            NGINX_LOG_BLOCKED_FORMAT

        # Configure log rotation for blocked logs
        create_logrotate nginx-blocked \
            "${NGINX_LOG_BLOCKED_LOCATION}/${NGINX_LOG_BLOCKED_FILE}" \
            nginx-blocked-"${NGINX_LOG_BLOCKED_FORMAT}" \
            "${NGINX_USER}" "${NGINX_GROUP}"
    fi

    ### Handle wildcard log files (if they exist)
    # Wildcard access logs
    if [ -f "${NGINX_ACCESS_LOG_LOCATION}/*-access.log" ]; then
        set -f  # Disable globbing to handle wildcard paths correctly
        create_logrotate nginx-wildcard \
            "${NGINX_LOG_ACCESS_LOCATION}/*-access.log" \
            nginx-"${NGINX_LOG_ACCESS_FORMAT}" \
            "${NGINX_USER}" "${NGINX_GROUP}"
        set +f  # Re-enable globbing
    fi

    # Wildcard error logs
    if [ -f "${NGINX_ERROR_LOG_LOCATION}/*-error.log" ]; then
        set -f  # Disable globbing to handle wildcard paths correctly
        create_logrotate nginx-error-wildcard \
            "${NGINX_LOG_ERROR_LOCATION}/*-error.log" \
            nginx-error-standard,nginx-error-alt-standard \
            "${NGINX_USER}" "${NGINX_GROUP}"
        set +f  # Re-enable globbing
    fi
}

# Configure Nginx maintenance mode.
# This function sets up the Nginx maintenance mode based on the specified type (local, proxy, or redirect).
# It updates templates, manages custom maintenance pages, and adjusts configuration files accordingly.
nginx_configure_maintenance() {
    ### Update Nginx templates with required variables
    # Replace placeholders in all templates with the listening port
    update_template "/etc/nginx/templates/*.template" NGINX_LISTEN_PORT

    ### Handle maintenance mode configuration based on type
    case "${NGINX_MAINTENANCE_TYPE,,}" in

        # Local maintenance page
        local )
            # Update the local maintenance page template with file and path variables
            update_template /etc/nginx/templates/maintenance.template \
                NGINX_MAINTENANCE_FILE \
                NGINX_MAINTENANCE_PATH

            # Download a custom maintenance page if a remote URL is provided
            if [ -n "${NGINX_MAINTENANCE_REMOTE_URL}" ]; then
                print_notice "Adding custom maintenance page from '${NGINX_MAINTENANCE_REMOTE_URL}'"
                silent curl -sSL -o "${NGINX_MAINTENANCE_PATH}/${NGINX_MAINTENANCE_FILE}" "${NGINX_MAINTENANCE_REMOTE_URL}"
            fi
        ;;

        # Proxy maintenance page
        proxy )
            # Validate the proxy URL before proceeding
            if [ -n "${NGINX_MAINTENANCE_PROXY_URL}" ]; then
                # Generate a maintenance template that proxies traffic to the specified URL
                cat <<EOF > /etc/nginx/templates/maintenance.template
server {
    ### Don't Touch This
    listen ${NGINX_LISTEN_PORT};
    server_name localhost;
    ###

    location / {
        proxy_pass              ${NGINX_MAINTENANCE_PROXY_URL};
        proxy_redirect          off;
        proxy_set_header        X-Real-IP \$remote_addr;
        proxy_set_header        X-Forwarded-For \$proxy_add_x_forwarded_for;
        proxy_set_header        X-Forwarded-Host \$server_name;
        proxy_ssl_server_name   on;
    }

### Don't edit past here
}
EOF
            else
                # Notify and exit if the proxy URL is not set
                sanity_var NGINX_MAINTENANCE_PROXY_URL "Set NGINX_MAINTENANCE_TYPE=proxy"
            fi
        ;;

        # Redirect maintenance page
        redirect )
            # Validate the redirect URL before proceeding
            if [ -n "${NGINX_MAINTENANCE_REDIRECT_URL}" ]; then
                print_notice "Setting maintenance redirect to '${NGINX_MAINTENANCE_REDIRECT_URL}'"
                # Generate a maintenance template that redirects traffic to the specified URL
                cat <<EOF > /etc/nginx/templates/maintenance.template
server {
    listen       ${NGINX_LISTEN_PORT};
    server_name  localhost;

    rewrite ^/(.*) ${NGINX_MAINTENANCE_REDIRECT_URL};
}
EOF
            else
                # Notify and exit if the redirect URL is not set
                sanity_var NGINX_MAINTENANCE_REDIRECT_URL "Set NGINX_MAINTENANCE_TYPE=redirect"
            fi
        ;;
    esac

    ### Update ownership for the maintenance directory
    # Ensure the ownership of the maintenance files is set to the Nginx user and group
    chown -R "${NGINX_USER}:${NGINX_GROUP}" "${NGINX_MAINTENANCE_PATH}"
}

# Configure the operating mode of Nginx.
# This function configures Nginx to operate in one of the supported modes:
# maintenance, proxy, redirect, or normal. Each mode applies specific template
# modifications and settings based on the environment variables.
nginx_configure_mode() {
    case "${NGINX_MODE,,}" in

        # Maintenance mode: Disable all active sites and templates
        "maintenance" )
            print_warn "MAINTENANCE MODE ACTIVATED - THIS IMAGE WILL NOT SERVE PAGES"
            # Comment out all active site configurations
            sed -i "s|include /etc/nginx/sites.enabled/\*.conf;|#include /etc/nginx/sites.enabled/*.conf;|g" /etc/nginx/nginx.conf
            # Remove proxy and redirect templates
            sed -i "/include \/etc\/nginx\/templates\/proxy.template;/d" /etc/nginx/nginx.conf
            sed -i "/include \/etc\/nginx\/templates\/redirect.template;/d" /etc/nginx/nginx.conf
        ;;

        # Proxy mode: Route all traffic to the specified proxy URL
        "proxy" )
            # Ensure the proxy URL is set
            sanity_var NGINX_PROXY_URL "No Proxy URL"
            NGINX_ENABLE_CREATE_SAMPLE_HTML=FALSE
            print_notice "Proxy Mode Activated - Proxying all traffic to ${NGINX_PROXY_URL}"

            # Update proxy template with the specified URL
            update_template /etc/nginx/templates/proxy.template NGINX_PROXY_URL

            # Disable site and maintenance templates, ensure only proxy is active
            sed -i "/include \/etc\/nginx\/sites.enabled\/\*.conf;/d" /etc/nginx/nginx.conf
            sed -i "s|include /etc/nginx/templates/maintenance.template;|#include /etc/nginx/templates/maintenance.template;|g" /etc/nginx/nginx.conf
            sed -i "/include \/etc\/nginx\/templates\/redirect.template;/d" /etc/nginx/nginx.conf

            # Configure authentication for proxy mode
            case "${NGINX_AUTHENTICATION_TYPE,,}" in
                # Basic authentication
                "basic" )
                    sed -i '/server {/a\ \ \ \ \ auth_basic "'"${NGINX_AUTHENTICATION_TITLE}"'";\n\ \ \ \ \ auth_basic_user_file /etc/nginx/snippets/authentication/basic_authorized_users;' /etc/nginx/templates/proxy.template
                ;;
                # LDAP authentication
                "ldap" )
                    sed -i '/server {/a\ \ \ \ \ auth_ldap "'"${NGINX_AUTHENTICATION_TITLE}"'";\n\ \ \ \ \ auth_ldap_servers ldapserver;' /etc/nginx/templates/proxy.template
                ;;
                # LLNG (LemonLDAP::NG) authentication
                "llng" )
                    sed -i '/server {/a\ \ \ \ \  include /etc/nginx/snippets/authentication/llng_location_block;' /etc/nginx/templates/proxy.template
                    sed -i '/server {/a\ \ \ \ \  ### LLNG Authentication Checkpoint' /etc/nginx/templates/proxy.template
                    sed -i '/location \/ {/a\ \ \ \ \ \ \ \ include /etc/nginx/snippets/authentication/llng_auth_request;' /etc/nginx/templates/proxy.template
                    sed -i '/location \/ {/a\ \ \ \ \ \ \ \ ### LLNG Authentication handler' /etc/nginx/templates/proxy.template
                ;;
            esac
        ;;

        # Redirect mode: Redirect all traffic to a specified URL
        "redirect" )
            # Ensure the redirect URL is set
            sanity_var NGINX_REDIRECT_URL "No Redirect URL"
            NGINX_ENABLE_CREATE_SAMPLE_HTML=FALSE
            print_notice "Redirect Mode Activated - Redirecting all traffic to ${NGINX_REDIRECT_URL}"

            # Update redirect template with the specified URL
            update_template /etc/nginx/templates/redirect.template NGINX_REDIRECT_URL

            # Disable site and maintenance templates, ensure only redirect is active
            sed -i "/include \/etc\/nginx\/sites.enabled\/\*.conf;/d" /etc/nginx/nginx.conf
            sed -i "s|include /etc/nginx/templates/maintenance.template;|#include /etc/nginx/templates/maintenance.template;|g" /etc/nginx/nginx.conf
            sed -i "/include \/etc\/nginx\/templates\/proxy.template;/d" /etc/nginx/nginx.conf
        ;;

        # Normal mode: Default mode for serving configured sites
        "normal" | * )
            # Ensure only site templates are active, disable all others
            sed -i "s|include /etc/nginx/templates/maintenance.template;|#include /etc/nginx/templates/maintenance.template;|g" /etc/nginx/nginx.conf
            sed -i "/include \/etc\/nginx\/templates\/proxy.template;/d" /etc/nginx/nginx.conf
            sed -i "/include \/etc\/nginx\/templates\/redirect.template;/d" /etc/nginx/nginx.conf
        ;;
    esac
}

# Configure Nginx server settings.
# This function handles global server configurations, including buffering, compression,
# proxy settings, caching, and optimization, based on environment variables.
nginx_configure_server() {
    ### Update the main Nginx configuration template
    # Replace placeholders in the Nginx configuration file with actual values
    update_template /etc/nginx/nginx.conf \
        NGINX_CLIENT_BODY_BUFFER_SIZE \
        NGINX_CLIENT_BODY_TIMEOUT \
        NGINX_FASTCGI_BUFFERS \
        NGINX_FASTCGI_BUFFER_SIZE \
        NGINX_GROUP \
        NGINX_KEEPALIVE_REQUESTS \
        NGINX_KEEPALIVE_TIMEOUT \
        NGINX_SEND_TIMEOUT \
        NGINX_SERVER_NAMES_HASH_BUCKET_SIZE \
        NGINX_PROXY_BUFFERS \
        NGINX_PROXY_BUFFER_SIZE \
        NGINX_PROXY_BUSY_BUFFERS_SIZE \
        NGINX_UPLOAD_MAX_SIZE \
        NGINX_USER \
        NGINX_WORKER_CONNECTIONS \
        NGINX_WORKER_PROCESSES \
        NGINX_WORKER_RLIMIT_NOFILE

    ### Compression settings
    # Enable Brotli compression if specified
    if var_true "${NGINX_ENABLE_COMPRESSION_BROTLI}"; then
        update_template /etc/nginx/snippets/compression_brotli.conf \
            NGINX_COMPRESSION_BROTLI_LEVEL \
            NGINX_COMPRESSION_BROTLI_MIN_LENGTH \
            NGINX_COMPRESSION_BROTLI_TYPES \
            NGINX_COMPRESSION_BROTLI_WINDOW
    else
        sed -i "\|include /etc/nginx/snippets/compression_brotli.conf;|d" /etc/nginx/nginx.conf
    fi

    # Enable Gzip compression if specified
    if var_true "${NGINX_ENABLE_COMPRESSION_GZIP}"; then
        update_template /etc/nginx/snippets/compression_gzip.conf \
            NGINX_COMPRESSION_GZIP_BUFFERS \
            NGINX_COMPRESSION_GZIP_DISABLE \
            NGINX_COMPRESSION_GZIP_HTTP_VERSION \
            NGINX_COMPRESSION_GZIP_LEVEL \
            NGINX_COMPRESSION_GZIP_MIN_LENGTH \
            NGINX_COMPRESSION_GZIP_PROXIED \
            NGINX_COMPRESSION_GZIP_TYPES
        if var_false "${NGINX_COMPRESSION_GZIP_VARY}"; then
            sed -i "\|gzip_vary on;|d" /etc/nginx/snippets/compression_gzip.conf
        fi
    else
        sed -i "\|include /etc/nginx/snippets/compression_gzip.conf;|d" /etc/nginx/nginx.conf
    fi

    ### Security and protection settings
    # Enable DDOS protection if specified
    if var_true "${NGINX_ENABLE_DDOS_PROTECTION}"; then
        update_template /etc/nginx/snippets/ddos_protection.conf \
            NGINX_DDOS_CONNECTIONS_PER_IP \
            NGINX_DDOS_REQUESTS_PER_IP
    else
        sed -i "\|include /etc/nginx/snippets/ddos_protection.conf;|d" /etc/nginx/nginx.conf
    fi

    # Disable exploit protection if not enabled
    if var_false "${NGINX_ENABLE_EXPLOIT_PROTECTION}"; then
        sed -i "\|include /etc/nginx/snippets/exploit_protection.conf;|d" /etc/nginx/nginx.conf
    fi

    ### FastCGI reverse proxy settings
    # Enable or disable HTTPS termination for FastCGI
    if var_true "${NGINX_ENABLE_FASTCGI_HTTPS}"; then
        print_notice "Enable Nginx FastCGI HTTPS Termination Support"
        sed -i "s|fastcgi_param  HTTPS .*;|fastcgi_param  HTTPS on;|g" /etc/nginx/fastcgi_params
        PROTOCOL="https://"
    else
        print_debug "Disable Nginx FastCGI HTTPS Termination Support"
        sed -i "s|fastcgi_param  HTTPS .*;|fastcgi_param  HTTPS off;|g" /etc/nginx/fastcgi_params
        PROTOCOL="http://"
    fi

    ### Resolver settings
    # Update resolver if specified
    if [ -n "${NGINX_RESOLVER}" ]; then
        update_template /etc/nginx/snippets/resolver.conf NGINX_RESOLVER
    else
        sed -i "\|include /etc/nginx/snippets/resolver.conf;|d" /etc/nginx/nginx.conf
    fi

    ### Caching and file handling settings
    # Enable or disable open file cache
    if var_true "${NGINX_ENABLE_OPEN_FILE_CACHE}"; then
        update_template /etc/nginx/snippets/open_file_cache.conf \
            NGINX_OPEN_FILE_CACHE_INACTIVE \
            NGINX_OPEN_FILE_CACHE_MAX \
            NGINX_OPEN_FILE_CACHE_MIN_USES \
            NGINX_OPEN_FILE_CACHE_VALID
        sed -i "\|open_file_cache_errors on;|d" /etc/nginx/snippets/open_file_cache.conf
    else
        sed -i "\|include /etc/nginx/snippets/open_file_cache.conf;|d" /etc/nginx/nginx.conf
    fi

    ### Optimization and performance settings
    # This section configures various optimization and performance settings for Nginx.
    # It ensures that features like buffering, connection handling, and TCP settings are adjusted
    # based on environment variables.

    # Disable proxy buffering if it is not enabled
    # Removes proxy buffering configuration if the feature is disabled
    if var_false "${NGINX_ENABLE_PROXY_BUFFERING}"; then
        sed -i \
            -e "/proxy.*/d" \
            -e "/fastcgi_buffer_size/a\ \n    proxy_buffering off;" \
            /etc/nginx/nginx.conf
    fi

    # Disable reset timedout connections if not enabled
    # Removes the "reset_timedout_connection" directive from the configuration
    if var_false "${NGINX_ENABLE_RESET_TIMEDOUT_CONNECTION}"; then
        sed -i "\|reset_timedout_connection|d" /etc/nginx/nginx.conf
    fi

    # Disable multi_accept if it is not enabled
    # Removes the "multi_accept on" directive to prevent multiple simultaneous accept calls
    if var_false "${NGINX_ENABLE_MULTI_ACCEPT}"; then
        sed -i "\|multi_accept on;|d" /etc/nginx/nginx.conf
    fi

    # Remove epoll usage if not enabled
    # Deletes the "use epoll" directive from the configuration
    if var_false "${NGINX_ENABLE_EPOLL}"; then
        sed -i "\|use_epoll;|d" /etc/nginx/nginx.conf
    fi

    # Disable sendfile if it is not enabled
    # Removes the "sendfile" directive to disable efficient file transmission
    if var_false "${NGINX_ENABLE_SENDFILE}"; then
        sed -i "\|sendfile|d" /etc/nginx/nginx.conf
    fi

    # Disable site optimization if it is not enabled
    # Removes the inclusion of the "site_optimization.conf" snippet
    if var_false "${NGINX_ENABLE_SITE_OPTIMIZATION}"; then
        sed -i "\|include /etc/nginx/snippets/site_optimization.conf;|d" /etc/nginx/nginx.conf
    fi

    # Enable server tokens if requested
    # Restores server tokens if explicitly enabled by removing directives that hide them
    if var_true "${NGINX_ENABLE_SERVER_TOKENS}"; then
        sed -i "\|server_tokens off;|d" /etc/nginx/nginx.conf
        sed -i "\|more_clear_headers Server;|d" /etc/nginx/nginx.conf
    fi

    # Disable TCP_NOPUSH if not enabled
    # Removes the "tcp_nopush" directive for optimizing TCP packet handling
    if var_false "${NGINX_ENABLE_TCPNOPUSH}"; then
        sed -i "\|tcp_nopush|d" /etc/nginx/nginx.conf
    fi

    # Disable TCP_NODELAY if not enabled
    # Removes the "tcp_nodelay" directive to adjust TCP performance settings
    if var_false "${NGINX_ENABLE_TCPNODELAY}"; then
        sed -i "\|tcp_nodelay|d" /etc/nginx/nginx.conf
    fi

    ### Reverse proxy settings
    # Enable or disable reverse proxy
    if var_true "${NGINX_ENABLE_REVERSE_PROXY}"; then
        update_template /etc/nginx/snippets/reverse_proxy.conf \
            NGINX_REAL_IP_HEADER \
            NGINX_SET_REAL_IP_FROM
    else
        sed -i "\|include /etc/nginx/snippets/reverse_proxy.conf;|d" /etc/nginx/nginx.conf
    fi

    ### Miscellaneous settings
    # Remove monitoring configuration if monitoring is disabled
    if var_false "${ENABLE_ZABBIX}" || var_false "${CONTAINER_ENABLE_MONITORING}"; then
        sed -i "\|include /etc/nginx/snippets/monitoring.conf;|d" /etc/nginx/nginx.conf
    else
        update_template /etc/nginx/snippets/monitoring.conf NGINX_VERSION
    fi

    # Configure stage environment (production or development)
    case "${STAGE,,}" in
        "production" | "staging")
            echo "fastcgi_param STAGE 'PRODUCTION';" >> /etc/nginx/fastcgi_params
        ;;
        "develop" | *)
            echo "fastcgi_param STAGE 'DEVELOP';" >> /etc/nginx/fastcgi_params
        ;;
    esac
}

# Configure site-specific authentication in Nginx.
# This function applies authentication settings (Basic, LDAP, or LLNG) to a specific site configuration
# or all sites if "all" is specified. It ensures that the necessary authentication directives
# are inserted into the appropriate site configuration files.
nginx_configure_site_authentication() {
    ### Determine target site configuration
    # If a site name is provided, validate it or set it to "all"
    if [ -n "${1}" ]; then
        if [ "${1,,}" = "all" ]; then
            # Apply configuration to all sites
            nginx_site_config="*"
        else
            # Check if the specified site configuration file exists
            if [ -f "/etc/nginx/sites.available/${1}.conf" ]; then
                nginx_site_config=${1}
            else
                # Print error and exit if the site does not exist
                print_error "Cannot configure Authentication for Site ${1} as it doesn't exist in /etc/nginx/sites.available!"
                exit 1
            fi
        fi
    else
        # Default to all sites if no site name is provided
        nginx_site_config="*"
    fi

    ### Apply authentication type to the site configuration
    case "${NGINX_AUTHENTICATION_TYPE,,}" in

        # Basic authentication
        "basic" )
            # Insert directives for basic authentication
            sed -i '/server {/a\ \ \ \ auth_basic "'"${NGINX_AUTHENTICATION_TITLE}"'";\n\ \ \ \ auth_basic_user_file /etc/nginx/snippets/authentication/basic_authorized_users;' /etc/nginx/sites.available/"${nginx_site_config}".conf
        ;;

        # LDAP authentication
        "ldap" )
            # Insert directives for LDAP authentication
            sed -i '/server {/a\ \ \ \ auth_ldap "'"${NGINX_AUTHENTICATION_TITLE}"'";\n\ \ \ \ auth_ldap_servers ldapserver;' /etc/nginx/sites.available/"${nginx_site_config}".conf
        ;;

        # LLNG (LemonLDAP::NG) authentication
        "llng" )
            # Check if PHP-FPM is managing LLNG attributes
            if [ ! -f "/etc/cont-init.d/20-php-fpm" ]; then
                # Insert directives for LLNG authentication when PHP-FPM is not present
                sed -i '/server {/a\ \ \ \ \  include /etc/nginx/snippets/authentication/llng_location_block;' /etc/nginx/sites.available/"${nginx_site_config}".conf
                sed -i '/server {/a\ \ \ \ \  ### LLNG Authentication Checkpoint' /etc/nginx/sites.available/"${nginx_site_config}".conf
                sed -i '/location \/ {/a\ \ \ \ \ \ \ \ include /etc/nginx/snippets/authentication/llng_auth_request;' /etc/nginx/sites.available/"${nginx_site_config}".conf
                sed -i '/location \/ {/a\ \ \ \ \ \ \ \ ### LLNG Authentication handler' /etc/nginx/sites.available/"${nginx_site_config}".conf
            else
                # Insert directives for LLNG authentication when PHP-FPM is managing attributes
                sed -i '/server {/a\ \ \ \ \  include /etc/nginx/snippets/authentication/llng_location_block;' /etc/nginx/sites.available/"${nginx_site_config}".conf
                sed -i '/server {/a\ \ \ \ \  ### LLNG Authentication handler' /etc/nginx/sites.available/"${nginx_site_config}".conf
                sed -i '/location \/ {/a\ \ \ \ \ \ \ \ include /etc/nginx/snippets/authentication/llng_auth_request;' /etc/nginx/sites.available/"${nginx_site_config}".conf
                sed -i '/location \/ {/a\ \ \ \ \ \ \ \ ### LLNG Authentication handler' /etc/nginx/sites.available/"${nginx_site_config}".conf
            fi
        ;;
    esac
}

# Configure site-specific blockbot rules in Nginx.
# This function adds blockbot configurations to a specific site or all sites based on the input.
# It ensures that the blockbot configuration is included in the appropriate site configuration files.
nginx_configure_site_blockbots() {
    ### Determine target site configuration
    # If a site name is provided, validate it or set it to "all"
    if [ -n "${1}" ]; then
        if [ "${1,,}" = "all" ]; then
            # Apply configuration to all sites
            nginx_site_config="*"
        else
            # Check if the specified site configuration file exists
            if [ -f "/etc/nginx/sites.available/${1}.conf" ]; then
                nginx_site_config=${1}
            else
                # Print error and exit if the site does not exist
                print_error "Cannot configure Blockbots for Site ${1} as it doesn't exist in /etc/nginx/sites.available!"
                exit 1
            fi
        fi
    else
        # Default to all sites if no site name is provided
        nginx_site_config="*"
    fi

    ### Add blockbot configuration to the site configuration
    # Insert the blockbot include directive at the specified marker in the configuration file
    sed -i "\|### Don't edit past here|a\ \ \ \ \  include /etc/nginx/snippets/blockbots/blockbots.conf;" /etc/nginx/sites.available/"${nginx_site_config}".conf
}

# Configure site-specific include directives in Nginx.
# This function adds custom include directives to a specific site configuration or all site configurations.
# It ensures the include directive is properly inserted at the designated marker in the configuration file.
nginx_configure_site_includes() {
    ### Determine target site configuration
    # If a site name is provided, validate it or set it to "all"
    if [ -n "${1}" ]; then
        if [ "${1,,}" = "all" ]; then
            # Apply configuration to all sites
            nginx_site_config="*"
        else
            # Check if the specified site configuration file exists
            if [ -f "/etc/nginx/sites.available/${1}.conf" ]; then
                nginx_site_config=${1}
            else
                # Print error and exit if the site does not exist
                print_error "Cannot configure Includes for Site ${1} as it doesn't exist in /etc/nginx/sites.available!"
                exit 1
            fi
        fi
    else
        # Default to all sites if no site name is provided
        nginx_site_config="*"
    fi

    ### Add include directive to the site configuration
    # Insert the include directive at the specified marker in the configuration file
    sed -i "\|### Don't edit past here|a\ \ \ \ \    include ${NGINX_INCLUDE_CONFIGURATION};" /etc/nginx/sites.available/"${nginx_site_config}".conf
}

# Configure the default site for Nginx.
# This function creates a default site configuration if no other site is enabled,
# no existing default configuration is present, and PHP-FPM is not managing the site.
# It generates a basic Nginx server block with placeholders for customization.
nginx_configure_site_default() {

    ### Check conditions to create the default site
    # Ensure no site is enabled, no default configuration exists, and PHP-FPM is not managing the site
    if [ -z "${NGINX_SITE_ENABLED}" ] && [ ! -f "/etc/nginx/sites.available/default.conf" ] && [ ! -f "/etc/cont-init.d/20-php-fpm" ]; then

        ### Create the default site configuration
        # Generate a basic Nginx server block with custom directives and include snippets
        cat <<EOF > /etc/nginx/sites.available/default.conf
server {
    ### Don't Touch This
    listen ${NGINX_LISTEN_PORT};
    server_name localhost;
    root ${NGINX_WEBROOT};
    ###

    ### Populate your custom directives here
    index  index.html index.htm;

    location / {
    #
    }

    ### Don't edit past here

    include /etc/nginx/snippets/site_optimization.conf;
    include /etc/nginx/snippets/exploit_protection.conf;
}
EOF

        ### Mark the default site as enabled
        # Set the default site as the active site
        NGINX_SITE_ENABLED=default
    fi
}

# Create a sample index.html file in the webroot directory.
# This function generates a default HTML page if no index.html file exists in the specified webroot directory.
# The generated page serves as a placeholder to confirm the container is working correctly.
nginx_create_sample_html() {
    ### Check if index.html already exists
    # Only create the sample HTML file if it does not already exist
    if [ ! -f "${NGINX_WEBROOT}/index.html" ]; then
        # Notify user about the creation of a sample index.html file
        print_notice "Creating sample index.html"

        ### Ensure the webroot directory exists
        # Create the webroot directory if it does not already exist
        mkdir -p "${NGINX_WEBROOT}"

        ### Generate the sample index.html file
        # Write a basic HTML file to the webroot directory
        cat <<EOF >"${NGINX_WEBROOT}"/index.html
<html>
<title>Default Page</title>
<h2>Container is working</h2>
<p>Congratulations! Your ${IMAGE_NAME} image is working. You are seeing this because you don't have an index.html file in your ${NGINX_WEBROOT} directory.</p>
</html>
EOF

        ### Set appropriate ownership for the webroot directory
        # Ensure the generated files are owned by the Nginx user and group
        chown -R "${NGINX_USER}":"${NGINX_GROUP}" "${NGINX_WEBROOT}"
    fi
}

# Enable an Nginx site or all sites.
# This function creates symbolic links from `/etc/nginx/sites.available` to `/etc/nginx/sites.enabled`
# for a specified site or all available sites, making them active.
nginx_site_enable() {
    ### Validate input argument
    # Ensure that a site name or "all" is provided as an argument
    if [ -n "${1}" ]; then

        ### Enable all sites
        if [ "${1,,}" = "all" ]; then
            # Check if there are any available site configurations
            if [ "$(ls -A /etc/nginx/sites.available/)" ]; then
                # Enable nullglob to handle empty directories gracefully
                shopt -s nullglob
                # Loop through all site configuration files and create symbolic links
                for site in /etc/nginx/sites.available/*.conf; do
                    print_debug "Enabling Nginx Site '$(basename "${site}")'"
                    ln -sf /etc/nginx/sites.available/"$(basename "${site}")" /etc/nginx/sites.enabled/
                done
                # Disable nullglob to restore default shell behavior
                shopt -u nullglob
            else
                print_warn "No site configurations found in /etc/nginx/sites.available to enable."
            fi

        ### Enable a specific site
        else
            # Check if the specified site configuration exists
            if [ -f "/etc/nginx/sites.available/${1}.conf" ]; then
                print_debug "Enabling Nginx Site '${1}.conf'"
                ln -sf /etc/nginx/sites.available/"${1}.conf" /etc/nginx/sites.enabled/
            else
                # Print error and exit if the site configuration does not exist
                print_error "Cannot enable site ${1} as it doesn't exist in /etc/nginx/sites.available!"
                exit 1
            fi
        fi

    else
        # Print error if no argument is provided
        print_error "Need configuration file as argument to utilize 'nginx_site_enable' function"
        exit 1
    fi
}

# Disable an Nginx site or all sites.
# This function removes symbolic links from `/etc/nginx/sites.enabled`,
# effectively disabling the specified site or all sites.
nginx_site_disable() {
    ### Validate input argument
    # Ensure that a site name or "all" is provided as an argument
    if [ -n "${1}" ]; then

        ### Disable all sites
        if [ "${1,,}" = "all" ]; then
            # Enable nullglob to handle empty directories gracefully
            shopt -s nullglob
            # Loop through all enabled site configuration files and remove symbolic links
            for site in /etc/nginx/sites.enabled/*.conf; do
                print_debug "Disabling Nginx Site '$(basename "${site}")'"
                rm -rf /etc/nginx/sites.enabled/"$(basename "${site}")"
            done
            # Disable nullglob to restore default shell behavior
            shopt -u nullglob

        ### Disable a specific site
        else
            # Check if the specified site configuration exists in enabled sites
            if [ -f "/etc/nginx/sites.enabled/${1}.conf" ]; then
                print_debug "Disabling Nginx Site '${1}.conf'"
                rm -rf /etc/nginx/sites.enabled/"${1}"*
            else
                # Print error and exit if the site configuration does not exist
                print_error "Cannot disable site ${1} as it doesn't exist in /etc/nginx/sites.enabled!"
                exit 1
            fi
        fi

    else
        # Print error if no argument is provided
        print_error "Need configuration file as argument to utilize 'nginx_site_disable' function"
        exit 1
    fi
}

# Perform post-initialization tasks for Nginx.
# This function handles enabling site configurations, executing custom scripts and commands,
# and resetting permissions for the webroot directory based on provided configurations.
nginx_post_init() {
    ### Enable Nginx site configurations
    # Check if application-specific configurations are enabled
    if var_true "${NGINX_ENABLE_APPLICATION_CONFIGURATION}"; then
        if [ -n "${NGINX_SITE_ENABLED}" ]; then
            # Enable specified sites if not set to "null"
            if [ "${NGINX_SITE_ENABLED,,}" != "null" ]; then
                sites=$(echo "${NGINX_SITE_ENABLED}" | tr "," "\n")
                for site in $sites; do
                    nginx_site_enable "${site}"
                done
            fi
        else
            # Enable all available sites by default
            nginx_site_enable all
        fi
    fi

    ### Execute post-initialization scripts
    if [ -n "${NGINX_POST_INIT_SCRIPT}" ]; then
        print_debug "Found Post Init Scripts"
        # Split the script paths into an array and execute each script
        post_scripts=$(echo "${NGINX_POST_INIT_SCRIPT}" | tr "," "\n")
        for post_script in $post_scripts; do
            if [ -f "${post_script}" ]; then
                print_debug "Executing post init script '${post_script}'"
                chmod +x "${post_script}"
                "${post_script}"
            else
                # Print error if the script does not exist
                print_error "Tried to run post script '${post_script}' but it does not exist!"
            fi
        done
    fi

    ### Execute post-initialization commands
    if [ -n "${NGINX_POST_INIT_COMMAND}" ]; then
        print_debug "Found Post Init Command"
        # Split the commands into an array and execute each command
        post_commands=$(echo "${NGINX_POST_INIT_COMMAND}" | tr "," "\n")
        for post_command in $post_commands; do
            print_debug "Executing post init command '${post_command}'"
            "${post_command}"
        done
    fi

    ### Reset permissions for the webroot directory
    # Ensure the webroot directory exists
    mkdir -p "${NGINX_WEBROOT}"
    # Reset permissions if forced
    if var_true "${NGINX_FORCE_RESET_PERMISSIONS}"; then
        chown -R "${NGINX_USER}":"${NGINX_GROUP}" "${NGINX_WEBROOT}"
    fi
}
